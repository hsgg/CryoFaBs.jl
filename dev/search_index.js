var documenterSearchIndex = {"docs":
[{"location":"tutorial_3d/#D-Tutorial","page":"Tutorial in 3D","title":"3D Tutorial","text":"","category":"section"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"In this tutorial we will do everything to show how to create your own cryofunks and use CryoFaB for a 3D analysis with spherical symmetry, but arbitrary masks.","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"First, let's load some packages you will need:","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"using Healpix\nusing CryoFaBs","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"Next, we assume a galaxy survey with distances between 500h^-1 rm Mpc and 1500h^-1rm Mpc. For the angular resolution of the HEALPix map we choose n_rm side=32. Don't go too high in n_rm side, as that will take a lot of memory! For the radial resolution we choose 50 bins.","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"rmin = 500.0\nrmax = 1500.0\nnside = 32\nnbins = 50\nnpix = nside2npix(nside)\nmask = fill(1.0, npix)\nmask[(npix ÷ 2):end] .= 0\nmask = HealpixMap{Float64, Healpix.RingOrder}(mask)\ncfb = AngRadCryoFaB(mask, rmin, rmax, nbins)","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"Here we created a mask that covers just about half the sky. In the last line we create the CryoFaB that contains the cryofunks for the harmonic transform. The function nside2npix() is provided by Healpix.jl.","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"To demonstrate the analysis of a 3D survey, let's create some 10^5 galaxies with random positions:","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"Ngals = 10^5\nrθϕ = fill(NaN, 3, Ngals)\n@. rθϕ[1,:] = rmin + (rmax - rmin) * rand()\n@. rθϕ[2,:] = π/2 * rand()\n@. rθϕ[3,:] = 2 * π * rand() - π","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"The coordinates are the radial distance, θ, and ϕ. This is a non-uniform galaxy catalog. Therefore, we expect some funkyness in the radial direction. It also isn't isotropic, so we really should find a better example. We have also ensured that only the Northern cap is populated with galaxies, but if you need, there is the isinsurvey() function to check if a given galaxy is in the CryoFaB's footprint.","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"In any case, the array rθϕ contains the r-coordinates of all the galaxies in rθϕ[1,:], all the theta-coordinates are in rθϕ[2,:], and all the phi-coordinates are in rθϕ[3,:].","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"Next, we assign each galaxy to its nearest grid cell by calling","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"n_g = calc_numgals_per_cell(rθϕ, cfb)\nδr = numgals2densitycontrast(n_g)","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"where the second line further estimates the density contrast. As if you wouldn't be able to guess that from the name.","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"Now we can convert to cryospace,","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"δnlm = cfb \\ δr","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"The power spectrum is constructed as","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"P = @. δnlm * conj(δnlm)","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"We have included the complex conjugate eventhough the cryofunks are real, just to remind ourselves.","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"One more step is needed: the combination of pixel-window and survey geometry, aka the cryo-window.","category":"page"},{"location":"tutorial_3d/","page":"Tutorial in 3D","title":"Tutorial in 3D","text":"...","category":"page"},{"location":"myindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"myindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"tutorial_2d/#D-Tutorial","page":"Tutorial in 2D","title":"2D Tutorial","text":"","category":"section"},{"location":"tutorial_2d/","page":"Tutorial in 2D","title":"Tutorial in 2D","text":"Here we give a brief introduction on how to use CryoFaB on the 2D sphere.","category":"page"},{"location":"tutorial_2d/","page":"Tutorial in 2D","title":"Tutorial in 2D","text":"...","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [CryoFaBs]","category":"page"},{"location":"reference/#CryoFaBs.CryoFaBs","page":"Reference","title":"CryoFaBs.CryoFaBs","text":"This module implements functions to create your own fabulous basis functions,     primarily for the analysis of galaxy redshift surveys.\n\n\n\n\n\n","category":"module"},{"location":"reference/#CryoFaBs.CryoFaB","page":"Reference","title":"CryoFaBs.CryoFaB","text":"The abstract type CryoFaB defines a common interface for the bases defined in         this module.\n\n        δnlm = cfb \\ δθϕr[:]\n\n\n\n\n\n","category":"type"},{"location":"reference/#CryoFaBs.calc_numgals_per_cell_v1-Tuple{Any, CryoFaB}","page":"Reference","title":"CryoFaBs.calc_numgals_per_cell_v1","text":"calcnumgalsper_cell(rθϕ, cfb::CryoFaB)\n\nCalculate the number of galaxies in rθϕ in each pixel or voxel in the survey that cfb can act on. The radial coordinates are in rθϕ[1,:], etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CryoFaBs.estimate_density_contrast-Tuple{Any, AngRadCryoFaB}","page":"Reference","title":"CryoFaBs.estimate_density_contrast","text":"estimatedensitycontrast(rθϕ, cfb::CryoFaB)\n\nEstimate the density contrast from the galaxy positions in rθϕ.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CryoFaBs","category":"page"},{"location":"#CryoFaBs","page":"Home","title":"CryoFaBs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for CryoFaBs. The paper describing the details of the algorithm will be on arXiv shortly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is similar in spirit to Healpix.jl and SphericalFourierBesselDecompositions.jl. It performs a harmonic analysis (usually of galaxy surveys) exploiting the isotropy on the sky despite non-isotropic window functions and masks. It does this in both 2D and 3D.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The central objects of this package are of the abstract type CryoFaB, which behaves like a matrix. For example, if δr is the density contrast in configuration space and cfb is a CryoFaB, then the transform into cryospace is performed via","category":"page"},{"location":"","page":"Home","title":"Home","text":"δnlm = cfb \\ δr","category":"page"},{"location":"","page":"Home","title":"Home","text":"CryoFaB-objects like AngularCryoFaB (for 2D on the sphere) and AngRadCryoFaB (for 3D) are also used to convert between pixels (or voxels in 3D) and a cell index, e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"pix = coord2cell(cfb, θ, ϕ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is similar to the function ang2pix() from Healpix.jl and indeed it is the same in the 2D case. In 3D the same is done by using a different cfb object of type AngRadCryoFaB and additionally passing a radial coordinate.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The CryoFaB-objects also encode everything that is needed for the pixel window.","category":"page"}]
}
